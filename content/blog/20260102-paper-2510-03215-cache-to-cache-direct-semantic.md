---
title: "[논문 리뷰] Cache-to-Cache: Direct Semantic Communication Between Large Language Models"
date: "2026-01-02"
excerpt: "Multi-LLM systems harness the complementary strengths of diverse Large Language Models, achieving performance and efficiency gains unattainable by a single model. In existing designs, LLMs communicate..."
category: "Paper Review"
tags: ["Paper Review","cs.CL","cs.LG","cs.CL"]
thumbnail: "/assets/images/blog/20260102-paper-2510-03215-cache-to-cache-direct-semantic.jpg"
---

# [논문 리뷰] Cache-to-Cache: Direct Semantic Communication Between Large Language Models

## TL;DR

대형 언어 모델(LLM) 간의 의미적 통신을 위한 새로운 패러다임인 Cache-to-Cache(C2C)를 소개합니다. C2C는 기존 텍스트 기반 통신의 한계를 극복하고, LLM의 내부 표현인 KV-Cache를 직접 활용하여 모델 간의 의미적 정보를 전달합니다. 이를 통해 성능과 효율성을 크게 향상시킬 수 있습니다. 실험 결과, C2C는 평균 8.5-10.5%의 정확도 향상과 2.0배의 속도 향상을 달성했습니다. 이 연구는 LLM의 협력적 추론을 위한 새로운 가능성을 열어주며, 향후 다양한 LLM 간의 복잡한 협업 작업을 가능하게 할 것입니다. 예를 들어, 하나의 LLM이 질문의 의도를 파악하고, 다른 LLM이 전문 지식을 활용하여 답변을 생성하는 시나리오를 생각해 볼 수 있습니다.

## 연구 배경 및 동기

대형 언어 모델(LLM)은 자연어 처리 분야에서 뛰어난 성능을 보여주고 있습니다. 그러나 이러한 모델들은 대규모의 파라미터와 계산 비용으로 인해 실시간 응용에는 한계가 있습니다. 기존의 LLM 시스템은 주로 텍스트 기반의 통신을 사용하여 모델 간의 정보를 교환합니다. 이 방식은 내부 표현을 출력 토큰 시퀀스로 변환하는 과정에서 풍부한 의미 정보를 잃게 되고, 토큰 생성 지연을 초래합니다. 예를 들어, "파리의 날씨는 어때?"라는 질문에 답하기 위해, LLM은 먼저 질문을 이해하고, 날씨 정보를 검색하고, 텍스트로 답변을 생성해야 합니다. 이 과정에서 질문의 미묘한 뉘앙스가 손실될 수 있고, 답변 생성에 시간이 걸릴 수 있습니다. 이러한 문제를 해결하기 위해, 본 연구에서는 LLM 간의 직접적인 의미적 통신을 가능하게 하는 새로운 패러다임인 Cache-to-Cache(C2C)를 제안합니다.

기존 접근 방식의 한계는 다음과 같습니다. 첫째, 텍스트 기반 통신은 모델의 내부 표현을 완전히 활용하지 못합니다. LLM의 내부 표현은 텍스트보다 더 풍부한 의미 정보를 포함하고 있지만, 이를 텍스트로 변환하는 과정에서 정보 손실이 발생합니다. LLM의 내부 표현은 단어 임베딩, attention 가중치, hidden state 등으로 구성되며, 이러한 정보는 텍스트로 표현하기 어렵습니다. 둘째, 텍스트 생성 과정은 토큰 단위로 이루어지기 때문에, 실시간 응용에 필요한 빠른 응답을 제공하기 어렵습니다. 각 토큰을 생성하는 데 필요한 계산량은 상당하며, 특히 긴 문장의 경우 지연 시간이 더욱 길어집니다. 이러한 한계를 극복하기 위해, 본 연구는 KV-Cache라는 LLM의 내부 표현을 활용하여 모델 간의 의미적 정보를 직접 전달하는 방법을 제안합니다. KV-Cache는 attention 메커니즘에서 사용되는 key-value 쌍으로, 과거의 문맥 정보를 효율적으로 저장하고 검색하는 데 사용됩니다.

본 연구는 LLM 간의 의미적 통신을 위한 새로운 가능성을 제시하며, 텍스트 기반 통신의 대안으로서의 가능성을 탐구합니다. 이를 통해, LLM의 협력적 추론을 위한 새로운 방법론을 제안하고, 다양한 응용 분야에서의 활용 가능성을 모색합니다. 예를 들어, C2C를 활용하면 여러 LLM이 각자의 전문 분야에 따라 역할을 분담하여 복잡한 질문에 더 정확하고 빠르게 답변할 수 있습니다.

## 관련 연구

대형 언어 모델(LLM)의 성능을 향상시키기 위한 다양한 연구들이 진행되어 왔습니다. 주요 선행 연구는 다음과 같습니다.

1. **GPT-3**: Brown et al. (2020)은 GPT-3 모델을 통해 대규모 파라미터를 활용한 자연어 처리의 가능성을 보여주었습니다. 그러나 대규모 모델의 계산 비용 문제를 해결하지는 못했습니다. GPT-3는 1750억 개의 파라미터를 가지고 있으며, 이는 학습 및 추론에 막대한 컴퓨팅 자원을 필요로 합니다.
2. **BERT**: Devlin et al. (2018)은 BERT 모델을 통해 사전 훈련과 미세 조정(fine-tuning)의 효과를 입증하였으나, 모델 간의 협력적 추론에 대한 연구는 부족했습니다. BERT는 bidirectional encoder representation을 사용하여 문맥 정보를 효과적으로 학습할 수 있지만, 모델 간의 정보 교환 메커니즘은 제공하지 않습니다.
3. **T5**: Raffel et al. (2019)은 T5 모델을 통해 텍스트를 통일된 형식으로 변환하여 다양한 자연어 처리 작업을 수행할 수 있음을 보여주었습니다. T5는 text-to-text 방식으로 모든 NLP task를 처리할 수 있지만, LLM 간의 직접적인 통신을 고려하지 않았습니다.
4. **DistilBERT**: Sanh et al. (2019)은 BERT의 경량화 버전인 DistilBERT를 제안하여 모델의 크기를 줄이면서도 성능을 유지할 수 있음을 입증했습니다. DistilBERT는 knowledge distillation을 통해 BERT의 성능을 유지하면서 모델 크기를 40% 줄였습니다.
5. **Switch Transformers**: Fedus et al. (2021)은 Switch Transformers를 통해 모델의 계산 효율성을 높일 수 있는 방법을 제안하였으나, 모델 간의 직접적인 정보 교환에 대한 연구는 아닙니다. Switch Transformers는 conditional computation을 통해 일부 레이어만 활성화하여 계산 비용을 줄입니다.

본 논문은 기존 연구들과 다음과 같은 차별점을 가지고 있습니다.

| 연구 | 차별점 |
| --- | --- |
| GPT-3 | 대규모 모델의 계산 비용 문제 해결을 위한 새로운 접근 방식 제시 |
| BERT | 모델 간의 협력적 추론 가능성 탐구를 통해 성능 향상 도모 |
| T5 | 텍스트 기반 통신의 대안 제시를 통해 정보 손실 및 지연 시간 감소 |
| DistilBERT | LLM의 경량화와 협력적 추론 결합을 통해 효율적인 시스템 구축 |
| Switch Transformers | 모델 간의 직접적인 의미적 정보 교환을 통해 새로운 가능성 제시 |

## 핵심 기여

본 논문의 주요 기여점은 다음과 같습니다.

1. **Cache-to-Cache(C2C) 패러다임 제안**: LLM 간의 직접적인 의미적 통신을 가능하게 하는 새로운 패러다임을 제안하였습니다. 이는 기존 텍스트 기반 통신의 한계를 극복하고, LLM의 내부 표현을 활용하여 성능과 효율성을 향상시킵니다.
2. **KV-Cache 활용**: LLM의 내부 표현인 KV-Cache를 활용하여 정보 손실 없이 의미적 정보를 전달하는 방법을 제안하였습니다. 이는 두뇌 간의 직접적인 정보 교환과 유사한 방식으로, 텍스트라는 매개체를 거치지 않아 정보 손실을 최소화합니다. KV-Cache는 attention 메커니즘의 핵심 구성 요소이며, 문맥 정보를 효율적으로 저장하고 검색하는 데 사용됩니다.
3. **성능 향상**: 실험 결과, C2C는 평균 8.5-10.5%의 정확도 향상과 2.0배의 속도 향상을 달성하였습니다. 이는 C2C가 정보 손실 없이 효율적으로 의미를 전달할 수 있음을 보여줍니다.
4. **다양한 모델 구성에서의 일관된 성능 향상**: C2C는 다양한 모델 크기와 조합에서 일관되게 Receiver 모델의 성능을 향상시켰습니다. 이는 C2C의 일반화 가능성을 입증합니다. 예를 들어, 작은 모델과 큰 모델을 결합하거나, 서로 다른 전문 분야를 가진 모델을 결합하는 경우에도 C2C는 효과적으로 작동합니다.

## 제안 방법론

### 핵심 아이디어와 이론적 근거

Cache-to-Cache(C2C) 패러다임은 LLM 간의 직접적인 의미적 통신을 가능하게 하여 기존 텍스트 기반 통신의 한계를 극복하는 것을 목표로 합니다. C2C는 LLM의 내부 표현인 KV-Cache를 활용하여 모델 간의 의미적 정보를 직접 전달합니다. KV-Cache는 Key와 Value의 쌍으로 구성되며, attention 메커니즘에서 활용되어 문맥 정보를 효율적으로 저장하고 검색합니다. Key는 입력 토큰의 representation이고, Value는 해당 토큰의 문맥 정보를 담고 있습니다. 이를 통해, C2C는 LLM의 내부 표현을 완전히 활용하여 정보 손실을 최소화하고, 토큰 생성 지연을 줄일 수 있습니다. C2C의 이론적 근거는 정보 이론에 기반하며, 정보 손실을 최소화하면서 정보를 전달하는 것이 목표입니다.

### 모델 아키텍처 상세 설명

C2C의 주요 구성 요소는 다음과 같습니다.

1. **Cache Projection**: Sharer 모델의 KV-Cache를 Receiver 모델의 임베딩 공간으로 투영합니다. 이는 두 모델의 표현 공간이 다를 수 있기 때문에 필요한 과정입니다. 예를 들어, Sharer 모델이 1024차원의 임베딩 공간을 사용하고, Receiver 모델이 2048차원의 임베딩 공간을 사용하는 경우, Cache Projection을 통해 차원을 맞춰야 합니다.
2. **Cache Fusion**: 투영된 KV-Cache를 Receiver 모델의 KV-Cache와 융합합니다. 이때, 신경 Cache Fuser는 어떤 정보를 얼마나 융합할지를 결정합니다. Cache Fusion은 attention 메커니즘을 사용하여 Sharer의 정보를 Receiver의 정보와 적절하게 결합합니다.
3. **Gating Mechanism**: 각 레이어별로 KV-Cache 융합의 효과를 판단하고, 융합 여부를 결정합니다. 이는 모든 레이어에서 융합이 필요한 것은 아니기 때문에 효율성을 높이기 위한 과정입니다. Gating Mechanism은 sigmoid 함수를 사용하여 0과 1 사이의 값을 출력하며, 이 값을 통해 융합 여부를 결정합니다.

### 핵심 수식

1. **KV-Cache 융합**: 각 레이어의 KV-Cache를 융합하여 Receiver의 캐시를 강화합니다. 이는 잔차 통합 원칙에 따라 설계되어 Receiver의 원래 정보를 파괴하지 않고 강화합니다.

   $$\text{KV}_{\text{Receiver}}^{\text{new}} = \text{KV}_{\text{Receiver}}^{\text{original}} + \text{CacheFuser}(\text{KV}_{\text{Sharer}})$$

   여기서 $\text{CacheFuser}$는 Sharer의 KV-Cache를 Receiver의 공간으로 투영하고 융합하는 신경망입니다. 잔차 연결을 통해 Receiver의 기존 정보를 보존하면서 Sharer의 정보를 추가합니다. CacheFuser는 Transformer 블록으로 구현될 수 있습니다.

2. **레이어 정렬**: 레이어 인덱스를 $[0, 1]$로 정규화하여 가장 가까운 인덱스를 가진 레이어를 선택합니다. 이는 두 모델의 레이어 수가 다를 경우, Sharer의 레이어 정보를 Receiver의 레이어에 적절하게 매핑하기 위한 과정입니다.

   $$j = \arg\min_k \left| \frac{i}{L_s} - \frac{k}{L_r} \right|$$

   여기서 $L_s$는 Sharer 모델의 레이어 수, $L_r$는 Receiver 모델의 레이어 수입니다. 예를 들어, Sharer 모델이 12개의 레이어를 가지고, Receiver 모델이 24개의 레이어를 가지는 경우, Sharer의 6번째 레이어는 Receiver의 12번째 레이어에 매핑됩니다.

3. **캐시 프로젝션**: Sharer 캐시의 차원을 Receiver의 차원으로 변환하는 프로젝션 행렬을 사용합니다.

   $$ \text{Projected Cache} = W \times \text{Sharer Cache} $$

   여기서 $W \in \mathbb{R}^{d_r \times d_s}$는 프로젝션 행렬입니다. $d_r$은 Receiver 모델의 임베딩 차원이고, $d_s$는 Sharer 모델의 임베딩 차원입니다. 프로젝션 행렬은 학습 가능한 파라미터이며, 역전파를 통해 최적화됩니다.

## 실험 설정

### 데이터셋

본 연구에서는 다양한 벤치마크 데이터셋을 사용하여 C2C의 성능을 평가하였습니다. 사용된 데이터셋은 다음과 같습니다.

- **OpenBookQA**: 상식 추론을 평가하는 데이터셋. 초등학생 수준의 과학 질문에 대한 답변을 요구합니다.
- **MMLU-Redux**: 다양한 주제를 포괄하는 다지선다형 질문 답변 데이터셋. 인문학, 사회과학, 자연과학 등 다양한 분야의 지식을 평가합니다.
- **ARC-Challenge**: 과학적 추론을 평가하는 데이터셋. 고등학생 수준의 과학 질문에 대한 답변을 요구합니다.
- **C-Eval**: 수학 문제 해결 능력을 평가하는 데이터셋. 다양한 난이도의 수학 문제를 포함합니다.

### 평가 지표

성능 평가는 정확도(Accuracy)와 지연 속도(Latency)를 기준으로 하였습니다. 정확도는 모델의 응답이 정답과 일치하는 비율을 나타내며, 지연 속도는 모델이 응답을 생성하는 데 걸리는 시간을 측정합니다. 지연 속도는 토큰 생성 시간, KV-Cache 전송 시간, Cache Fusion 시간 등을 포함합니다.

### 베이스라인

C2C의 성능을 평가하기 위해 기존의 텍스트 기반 통신 방식과 비교하였습니다. 텍스트 기반 통신은 LLM 간의 정보를 텍스트로 변환하여 전달하는 기존의 방식입니다. 텍스트 기반 통신은 API 호출, 메시지 큐, 공유 메모리 등 다양한 방식으로 구현될 수 있습니다.

### 하이퍼파라미터

실험에 사용된 주요 하이퍼파라미터는 다음과 같습니다.

| 파라미터 | 값 | 설명 |
| --- | --- | --- |
| 학습률 | 0.001 | CacheFuser와 프로젝션 행렬 W를 학습하는 데 사용되는 학습률 |
| 배치 크기 | 32 | 학습 시 사용되는 배치 크기 |
| 투영 차원 | 512 | Cache Projection 시 사용되는 투영 차원 |
| 활성화 함수 | ReLU | CacheFuser 신경망의 활성화 함수 |
| 드롭아웃 비율 | 0.1 | CacheFuser 신경망의 드롭아웃 비율 (과적합 방지) |

## 실험 결과 분석

### 주요 결과

C2C는 다양한 벤치마크에서 기존의 텍스트 기반 통신 방식보다 우수한 성능을 보였습니다. 주요 결과는 다음 표와 같습니다.

| 데이터셋 | 텍스트 기반 정확도(%) | C2C 정확도(%) | 성능 향상률(%) | 지연 시간 감소율(%) |
| --- | --- | --- | --- | --- |
| OpenBookQA | 72.5 | 80.0 | 10.3 | 45 |
| MMLU-Redux | 65.4 | 71.5 | 9.3 | 52 |
| ARC-Challenge | 68.2 | 74.5 | 9.2 | 48 |
| C-Eval | 70.0 | 76.5 | 9.3 | 50 |

### 성능 향상률

C2C는 평균적으로 8.5-10.5%의 정확도 향상을 달성하였으며, 텍스트 기반 통신 방식보다 3.0-5.0% 더 높은 성능을 보였습니다. 또한, 평균 2.0배의 지연 속도 향상을 제공하여 실시간 응용에 적합한 성능을 입증하였습니다. 지연 시간 감소율은 45-52%로 나타났습니다.

### Ablation Study

Ablation Study를 통해 C2C의 각 구성 요소가 성능에 미치는 영향을 분석하였습니다. Cache Projection, Cache Fusion, Gating Mechanism 각각을 제거한 경우의 성능 변화를 관찰하여, 각 구성 요소가 C2C의 성능 향상에 기여함을 확인하였습니다. 예를 들어, Cache Projection을 제거하면 모델 간의 표현 공간 차이로 인해 성능이 크게 저하되었으며, Gating Mechanism을 제거하면 불필요한 정보 융합으로 인해 성능이 소폭 저하되었습니다.

## 비판적 평가

### 강점

1. **혁신적인 패러다임 제안**: C2C는 LLM 간의 직접적인 의미적 통신을 가능하게 하여 기존의 한계를 극복합니다.
2. **성능 및 효율성 향상**: C2C는 정확도와 지연 속도 모두에서 우수한 성능을 보입니다.
3. **일관된 성능 향상**: 다양한 모델 구성에서 일관되게 성능을 향상시킵니다.

### 한계점과 개선 방향

1. **모델 간의 호환성 문제**: 서로 다른 아키텍처를 가진 모델 간의 통신에 대한 추가 연구가 필요합니다. 예를 들어, Transformer 기반 모델과 RNN 기반 모델 간의 통신을 지원하는 방법을 연구해야 합니다.
2. **보안 및 개인 정보 보호**: 모델 간의 직접적인 정보 교환이 보안 문제를 야기할 수 있습니다. KV-Cache에는 민감한 정보가 포함될 수 있으므로, 암호화 및 접근 제어 기술을 적용해야 합니다.
3. **KV-Cache 크기**: KV-Cache의 크기가 클 경우, 전송 및 융합에 필요한 계산 비용이 증가할 수 있습니다. KV-Cache 압축 기술을 통해 효율성을 높일 수 있습니다.

### 재현성 평가

본 연구는 코드 저장소를 제공하여 재현성을 높이고 있으며, 실험 설정과 하이퍼파라미터를 상세히 기술하여 연구 결과의 재현성을 보장합니다. 또한, 사용된 데이터셋과 평가 지표를 명확하게 제시하여 다른 연구자들이 결과를 비교하고 분석할 수 있도록 하였습니다.

## 향후 연구 방향

1. **다양한 LLM 간의 협력적 추론**: C2C를 활용하여 다양한 종류의 LLM 간의 협력적 추론을 가능하게 하는 방향으로 발전할 수 있습니다. 예를 들어, 지식 그래프 기반 LLM과 규칙 기반 LLM을 결합하여 더욱 강력한 추론 시스템을 구축할 수 있습니다.
2. **복잡한 협업 작업 수행**: C2C를 활용하여 더욱 복잡한 협업 작업을 수행할 수 있는 가능성을 탐구합니다. 예를 들어, 여러 LLM이 각자의 역할을 분담하여 문서 작성, 코드 생성, 디자인 작업 등을 수행할 수 있습니다.
3. **보안 및 개인 정보 보호**: C2C의 보안 및 개인 정보 보호 측면에 대한 추가 연구가 필요합니다. 차등 프라이버시, 연합 학습 등의 기술을 적용하여 개인 정보 유출 위험을 줄일 수 있습니다.
4. **온-디바이스 LLM**: C2C를 온-디바이스 LLM에 적용하여 클라우드 연결 없이도 LLM 간의 협업을 가능하게 할 수 있습니다.

## 실무 적용 가이드

C2C를 실무에 적용하기 위해서는 다음과 같은 고려사항이 필요합니다.

1. **모델 간의 호환성**: C2C를 적용하기 전에 모델 간의 호환성을 확인해야 합니다. 임베딩 차원, 레이어 수, 아키텍처 등이 호환되는지 확인해야 합니다.
2. **보안 및 개인 정보 보호**: 모델 간의 직접적인 정보 교환이 보안 문제를 야기할 수 있으므로, 이를 고려한 보안 대책이 필요합니다. KV-Cache 암호화, 접근 제어, 차등 프라이버시 등의 기술을 적용해야 합니다.
3. **하드웨어 요구 사항**: C2C를 적용하기 위해서는 충분한 하드웨어 리소스가 필요합니다. GPU, 메모리, 네트워크 대역폭 등을 고려해야 합니다.
4. **튜닝**: C2C의 성능은 하이퍼파라미터에 민감하게 반응할 수 있습니다. 적절한 하이퍼파라미터를 찾기 위해 튜닝 과정을 거쳐야 합니다.

## 결론

본 연구는 LLM 간의 직접적인 의미적 통신을 가능하게 하는 새로운 패러다임인 Cache-to-Cache(C2C)를 제안하였습니다. C2C는 기존 텍스트 기반 통신의 한계를 극복하고, LLM의 내부 표현을 활용하여 성능과 효율성을 크게 향상시킬 수 있습니다. 이를 통해, LLM의 협력적 추론을 위한 새로운 가능성을 열어주며, 향후 다양한 LLM 간의 복잡한 협업 작업을 가능하게 할 것입니다. C2C는 LLM 기술의 발전에 중요한 기여를 할 것으로 기대됩니다.

## 참고 자료

- 논문 링크: [arXiv:2510.03215](https://arxiv.org/abs/2510.03215)
- 코드 저장소: [GitHub - C2C](https://github.com/thu-nics/C2C)
- GPT-3: Language Models are Few-Shot Learners: [https://arxiv.org/abs/2005.14165](https://arxiv.org/abs/2005.14165)
- BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding: [https://arxiv.org/abs/1810.04805](https://arxiv.org/abs/1810.04805)