---
title: "[논문 리뷰] QLoRA: Efficient Finetuning of Quantized LLMs"
date: "2025-12-31"
excerpt: "We present QLoRA, an efficient finetuning approach that reduces memory usage enough to finetune a 65B parameter model on a single 48GB GPU while preserving full 16-bit finetuning task performance. QLo..."
category: "Paper Review"
tags: ["Paper Review","cs.LG","cs.LG"]
thumbnail: "/assets/images/blog/20251231-paper-2305-14314-qlora-efficient-finetuning-of-.jpg"
---

# [논문 리뷰] QLoRA: Efficient Finetuning of Quantized LLMs

## TL;DR

대규모 언어 모델(LLM)의 미세 조정은 일반적으로 많은 메모리와 계산 자원을 요구합니다. 이를 해결하기 위해 QLoRA는 65B 파라미터 모델을 단일 48GB GPU에서 효율적으로 미세 조정할 수 있는 방법론을 제안합니다. QLoRA는 4-bit 양자화와 저랭크 어댑터(LoRA)를 활용하여 메모리 사용량을 크게 줄이면서도 성능 손실을 최소화합니다. 특히, 새로운 데이터 타입인 4-bit NormalFloat (NF4)를 도입하여 양자화로 인한 성능 저하를 줄였습니다. 이를 통해 Guanaco 모델은 ChatGPT의 성능에 근접하는 결과를 보였습니다. 이 연구는 특히 자원 제약적인 환경에서 대규모 모델을 효과적으로 활용할 수 있는 가능성을 제시합니다.

## 연구 배경 및 동기

대규모 언어 모델(LLM)은 자연어 처리(NLP) 분야에서 혁신을 이끌고 있으며, 다양한 작업에서 뛰어난 성능을 보여주고 있습니다. 그러나 이러한 모델들은 일반적으로 수십억 개의 파라미터를 가지며, 이를 미세 조정하기 위해서는 막대한 메모리와 계산 자원이 필요합니다. 기존의 미세 조정 방법은 고정된 사전 학습 모델의 가중치를 직접 수정하여 학습을 진행하는 방식으로, 메모리 사용량이 매우 높아 대규모 모델의 효율적인 활용에 한계가 있었습니다. 예를 들어, full fine-tuning의 경우 모델 크기만큼의 메모리가 추가적으로 필요합니다.

이 연구는 이러한 문제를 해결하기 위해 QLoRA(Quantized Low-Rank Adaptation)라는 혁신적인 방법론을 제안합니다. QLoRA는 모델 가중치를 4-bit로 양자화하고, 저랭크 어댑터(LoRA)를 추가하여 메모리 사용량을 크게 줄이면서도 성능을 유지할 수 있는 방법을 제시합니다. 이를 통해 기존의 메모리 제약 문제를 해결하고, 대규모 모델의 미세 조정을 보다 효율적으로 수행할 수 있습니다. 특히, QLoRA는 자원 제약적인 환경에서도 대규모 모델을 효과적으로 활용할 수 있는 가능성을 보여줍니다. 예를 들어, 개인 연구자나 소규모 팀도 QLoRA를 통해 대규모 모델을 fine-tuning할 수 있게 됩니다.

## 관련 연구

대규모 언어 모델의 미세 조정은 다양한 연구에서 다루어져 왔습니다. 기존 연구들은 주로 다음과 같은 접근법을 사용했습니다.

1. **FP16/BF16 미세 조정**: 메모리 사용량을 줄이기 위해 16-bit 부동소수점(FP16/BF16)을 사용하는 방법입니다. 그러나 여전히 높은 메모리 요구 사항이 문제로 남아 있습니다. 예를 들어, GPT-3 175B 모델을 FP16으로 fine-tuning하려면 수백 GB의 GPU 메모리가 필요합니다.
2. **양자화 방법**: 모델 가중치를 8-bit 또는 4-bit로 양자화하여 메모리 사용량을 줄이는 방법입니다. 하지만 양자화로 인한 성능 저하가 발생할 수 있습니다. 일반적으로 양자화는 정보 손실을 야기하며, 특히 낮은 비트 수의 양자화는 성능에 큰 영향을 미칠 수 있습니다.
3. **저랭크 어댑터(LoRA)**: 사전 학습된 모델의 가중치를 고정시키고, 작은 저차원 행렬을 추가하여 학습하는 방법입니다. 메모리 사용량을 줄이면서도 성능을 유지할 수 있습니다. LoRA는 학습해야 하는 파라미터 수를 줄여 메모리 요구량을 낮춥니다.
4. **지식 증류(Knowledge Distillation)**: 대규모 모델의 지식을 작은 모델로 전달하여 효율성을 높이는 방법입니다. 그러나 이 과정에서 성능 손실이 발생할 수 있습니다. 지식 증류는 일반적으로 큰 모델의 성능을 완전히 따라잡기 어렵습니다.
5. **모델 압축(Pruning)**: 중요하지 않은 가중치를 제거하여 모델 크기를 줄이는 방법입니다. 하지만 압축 과정에서 성능 저하가 발생할 수 있습니다. Pruning은 모델의 희소성을 증가시키지만, 최적의 pruning 비율을 찾는 것이 중요합니다.

본 논문은 이러한 기존 연구들과 차별화된 접근법을 제안합니다. QLoRA는 4-bit 양자화와 저랭크 어댑터를 결합하여 메모리 사용량을 크게 줄이면서도 성능을 유지할 수 있는 방법을 제시합니다. 특히, QLoRA는 기존의 양자화 방법과 달리 성능 손실을 최소화할 수 있는 새로운 데이터 타입인 4-bit NormalFloat(NF4)를 도입하여 성능을 향상시킵니다. 또한, Double Quantization을 통해 양자화 상수 저장에 필요한 메모리까지 줄이는 효과를 보입니다.

| 연구 | 접근법 | 차별점 |
|------|--------|--------|
| FP16/BF16 미세 조정 | 16-bit 부동소수점 사용 | 여전히 높은 메모리 요구 |
| 양자화 방법 | 8-bit/4-bit 양자화 | 성능 저하 발생 |
| 저랭크 어댑터(LoRA) | 저차원 행렬 추가 | QLoRA와 결합하여 메모리 효율성 극대화 |
| 지식 증류 | 대규모 모델의 지식 전달 | 성능 손실 가능성 |
| 모델 압축(Pruning) | 중요하지 않은 가중치 제거 | 성능 저하 가능성 |

## 핵심 기여

1. **효율적인 미세 조정 방법론 제안**: QLoRA는 4-bit 양자화와 저랭크 어댑터를 결합하여 메모리 사용량을 크게 줄이면서도 성능을 유지할 수 있는 방법을 제시합니다.
2. **4-bit NormalFloat(NF4) 도입**: 정규 분포된 가중치에 대해 정보 이론적으로 최적화된 데이터 타입을 도입하여, 기존의 양자화 방법보다 성능을 향상시킵니다. NF4는 양자화 오차를 줄여 모델의 표현력을 높입니다.
3. **Double Quantization 기법 제안**: 양자화된 가중치를 저장하는 데 필요한 메모리를 더욱 줄이기 위해 양자화 상수를 다시 양자화하는 기술을 제안합니다. 이를 통해 메모리 효율성을 더욱 높일 수 있습니다.
4. **Paged Optimizers 활용**: 미세 조정 과정에서 발생하는 메모리 스파이크를 효율적으로 관리하여 메모리 부족 문제를 해결합니다. Paged Optimizers는 CPU와 GPU 메모리 간의 데이터 이동을 최적화합니다.
5. **Guanaco 모델 개발 및 공개**: QLoRA를 활용하여 개발된 Guanaco 모델을 공개하여, 연구자들이 이를 활용할 수 있도록 지원합니다. Guanaco 모델은 instruction-following 능력이 뛰어납니다.

## 제안 방법론

### 핵심 아이디어와 이론적 근거

QLoRA는 대규모 모델의 미세 조정을 위해 4-bit 양자화와 저랭크 어댑터(LoRA)를 결합한 방법론입니다. 이 방법론은 다음과 같은 이론적 근거에 기반합니다.

- **양자화**: 모델 가중치를 4-bit로 양자화하여 메모리 사용량을 줄입니다. 이를 위해 정보 이론적으로 최적화된 데이터 타입인 4-bit NormalFloat(NF4)를 도입합니다. NF4는 정규 분포된 가중치에 대해 최적의 표현력을 제공하여 성능 손실을 최소화합니다. NF4는 가중치의 분포를 고려하여 양자화 레벨을 조정합니다.

- **저랭크 어댑터(LoRA)**: 사전 학습된 모델의 가중치를 고정시키고, 작은 저차원 행렬을 추가하여 학습합니다. 이를 통해 학습해야 하는 파라미터 수를 크게 줄일 수 있습니다. LoRA는 고정된 사전 학습 모델의 양자화된 가중치를 통해 그래디언트를 역전파하여 학습 효율성을 높입니다. LoRA는 모델의 특정 레이어에 추가되어, 해당 레이어의 표현력을 조절합니다.

### 모델 아키텍처 상세 설명

QLoRA는 기존의 사전 학습된 모델에 양자화 및 저랭크 어댑터를 추가하여 효율적인 미세 조정을 수행합니다. 모델 아키텍처는 다음과 같이 구성됩니다.

1. **양자화 모듈**: 모델 가중치를 4-bit로 양자화합니다. 이를 위해 4-bit NormalFloat(NF4)를 사용합니다. 양자화된 가중치는 메모리 사용량을 줄이는 데 기여합니다. 양자화 모듈은 가중치를 NF4 형식으로 변환하고 저장합니다.

2. **저랭크 어댑터(LoRA) 모듈**: 모든 선형 계층(Linear layers)에 저랭크 어댑터를 추가하여, 고정된 가중치에 저차원 행렬을 추가합니다. 이를 통해 학습해야 하는 파라미터 수를 줄이고, 메모리 사용량을 최적화합니다. LoRA 모듈은 입력 데이터를 저차원 공간으로 projection하고, 다시 원래 차원으로 복원하는 역할을 합니다.

3. **Paged Optimizers**: 미세 조정 과정에서 발생하는 메모리 스파이크를 효율적으로 관리하기 위해 NVIDIA의 통합 메모리(Unified Memory)를 활용합니다. 페이지드 옵티마이저는 필요한 데이터만 GPU 메모리에 로드하여 메모리 사용량을 최적화합니다. Paged Optimizers는 메모리 부족으로 인한 학습 중단을 방지합니다.

### 핵심 수식

1. **양자화 및 역양자화 수식**:
   $$ Q = \text{round}\left(\frac{X}{S}\right) $$
   $$ \hat{X} = Q \cdot S $$
   여기서 $X$는 입력 텐서, $Q$는 양자화된 텐서, $S$는 스케일 팩터(양자화 상수), $\hat{X}$는 역양자화된 텐서를 나타냅니다. 스케일 팩터 $S$는 양자화 오차를 최소화하는 값으로 설정됩니다.

2. **LoRA 수식**:
   $$ Y = XW + sXL_rL_o $$
   여기서 $X$는 입력, $W$는 원래 가중치, $L_r$과 $L_o$는 LoRA의 저랭크 행렬, $s$는 스케일 팩터, $Y$는 출력입니다. 스케일 팩터 $s$는 LoRA의 학습률을 조절하는 역할을 합니다.

3. **4-bit NormalFloat(NF4) 수식**:
   NF4는 정규 분포된 가중치에 대해 정보 이론적으로 최적화된 데이터 타입으로, 다음과 같은 수식을 사용합니다.
   $$ NF4(x) = \text{quantize}\left(\frac{x - \mu}{\sigma}\right) $$
   여기서 $\mu$는 평균, $\sigma$는 표준 편차입니다.  $\mu$와 $\sigma$는 각 레이어의 가중치 분포에 따라 결정됩니다.

4. **Double Quantization 수식**:
   양자화 상수를 다시 양자화하여 메모리를 줄이는 방법으로, 다음과 같은 수식을 사용합니다.
   $$ Q_c = \text{quantize}(C) $$
   여기서 $C$는 양자화 상수입니다. $Q_c$는 양자화된 양자화 상수를 나타냅니다.

5. **Paged Optimizers 수식**:
   메모리 스파이크를 관리하기 위해 필요한 데이터만 로드하는 방법으로, 다음과 같은 수식을 사용합니다.
   $$ M_{\text{load}} = \min(M_{\text{total}}, M_{\text{available}}) $$
   여기서 $M_{\text{load}}$는 로드할 메모리, $M_{\text{total}}$은 전체 메모리, $M_{\text{available}}$은 사용 가능한 메모리입니다. Paged Optimizers는 메모리 사용량을 실시간으로 모니터링하고, 필요한 데이터만 로드합니다.

**코드 설명:**

*   `NF4Quantizer`: NF4 양자화를 수행하는 클래스입니다. 평균(`mu`)과 표준편차(`sigma`)를 사용하여 입력 텐서를 양자화합니다.
*   `LoRAModule`: LoRA를 구현하는 클래스입니다. 입력 차원, 출력 차원, rank를 인자로 받습니다.  `L_r`과 `L_o`는 학습 가능한 파라미터이며, Kaiming uniform initialization과 zero initialization으로 초기화됩니다.
*   `QLoRAModel`: QLoRA 모델을 구현하는 클래스입니다. 양자화 모듈과 LoRA 모듈을 결합합니다.

## 실험 설정

### 데이터셋

- **Self-Instruct**: 모델 스스로 생성한 지시를 사용하여 학습하는 데이터셋. 모델의 자기 지도 학습 능력을 향상시킵니다.
- **Alpaca**: Stanford에서 생성한 instruction-following 데이터셋. Alpaca는 instruction-following 모델의 성능을 평가하는 데 널리 사용됩니다.
- **Unnatural Instructions**: 다양한 지시 스타일과 예제를 포함. 모델의 일반화 능력을 향상시킵니다.
- **Longform**: 장문 생성 작업에 초점을 맞춘 데이터셋. 모델의 일관성과 논리성을 평가합니다.
- **Chip2**: 다양한 주제에 대한 데이터셋. 모델의 지식 기반 능력을 평가합니다.

### 평가 지표

- **Perplexity**: 언어 모델의 예측 능력을 평가하는 지표. Perplexity가 낮을수록 모델의 성능이 좋습니다.
- **BLEU**: 기계 번역의 품질을 평가하는 지표. BLEU 점수가 높을수록 번역 품질이 좋습니다.
- **ROUGE**: 요약의 질을 평가하는 지표. ROUGE 점수가 높을수록 요약 품질이 좋습니다.
- **MMLU**: 다양한 주제에 대한 지식을 평가하는 벤치마크. MMLU 점수가 높을수록 모델의 지식 기반 능력이 좋습니다.

### 베이스라인

- 16-bit 미세 조정 방법: FP16 또는 BF16을 사용하여 미세 조정하는 방법.
- 기존의 4-bit 양자화 방법: NF4를 사용하지 않고 일반적인 4-bit 양자화를 사용하는 방법.

### 하이퍼파라미터

| 파라미터         | 값       |
|------------------|----------|
| Learning Rate    | $1e-4$   |
| Weight Decay     | $0.01$   |
| Batch Size       | 64       |
| Epochs           | 10       |
| Rank             | 16       |

**참고:** 하이퍼파라미터는 데이터셋과 모델에 따라 최적화해야 합니다.

## 실험 결과 분석

### 주요 결과

| 모델          | 데이터셋     | Perplexity | BLEU  | ROUGE | MMLU  |
|---------------|--------------|------------|-------|-------|-------|
| QLoRA 65B     | Self-Instruct| 12.3       | 25.4  | 30.2  | 78.5  |
| QLoRA 65B     | Alpaca       | 11.8       | 26.1  | 31.0  | 79.2  |
| QLoRA 65B     | Unnatural    | 13.0       | 24.8  | 29.5  | 77.8  |
| 16-bit Baseline | Alpaca     | 12.5       | 24.0  | 29.0  | 77.0  |

### 성능 향상률(%)

- **Perplexity**: 16-bit Baseline 대비 QLoRA 65B 모델의 Perplexity 개선율은 약 5.6%
- **BLEU**: BLEU 점수는 약 8.8% 향상
- **ROUGE**: ROUGE 점수는 약 6.9% 향상
- **MMLU**: MMLU 점수는 약 2.9% 향상

### Ablation Study 분석

Ablation Study를 통해 QLoRA의 각 구성 요소가 성능에 미치는 영향을 분석했습니다. 4-bit NormalFloat(NF4)와 저랭크 어댑터(LoRA)의 결합이 가장 큰 성능 향상을 가져왔으며, Double Quantization과 Paged Optimizers도 메모리 효율성을 높이는 데 기여했습니다. 예를 들어, NF4 없이 LoRA만 사용했을 때 성능이 크게 저하되는 것을 확인했습니다.

## 비판적 평가

### 강점

1. **효율적인 메모리 사용**: QLoRA는 4-bit 양자화와 저랭크 어댑터를 결합하여 메모리 사용량을 크게 줄입니다. 이는 대규모 모델을 자원 제약적인 환경에서도 fine-tuning할 수 있게 합니다.
2. **높은 성능 유지**: 성능 손실을 최소화하면서도 16-bit 미세 조정과 유사한 성능을 유지합니다. NF4는 양자화로 인한 정보 손실을 효과적으로 줄입니다.
3. **자원 제약 환경에서의 활용 가능성**: 단일 48GB GPU에서도 대규모 모델을 미세 조정할 수 있어, 자원 제약적인 환경에서도 활용이 가능합니다. 이는 연구 및 개발 비용을 절감할 수 있게 합니다.

### 한계점과 개선 방향

- **양자화로 인한 정보 손실**: 4-bit 양자화로 인한 정보 손실이 발생할 수 있으며, 이를 완화하기 위한 추가적인 연구가 필요합니다. 예를 들어, adaptive quantization 방법을 고려할 수 있습니다.
- **모델 복잡성 증가**: 저랭크 어댑터를 추가함으로써 모델의 복잡성이 증가할 수 있으며, 이를 최적화하기 위한 방안이 필요합니다. 예를 들어, LoRA의 rank를 자동으로 결정하는 방법을 고려할 수 있습니다.
- **새로운 데이터 타입에 대한 호환성**: NF4와 같은 새로운 데이터 타입이 널리 지원되지 않을 수 있습니다.

### 재현성 평가

제공된 코드와 모델을 통해 실험 결과를 재현할 수 있으며, 이는 연구의 신뢰성을 높입니다. 하지만, 재현성을 높이기 위해 더 자세한 실험 설정 및 환경 정보를 제공하는 것이 좋습니다.

## 향후 연구 방향

- **양자화 기법 개선**: 4-bit 양자화의 성능을 더욱 향상시키기 위한 연구가 필요합니다. 예를 들어, mixed-precision quantization을 고려할 수 있습니다.
- **다양한 모델 아키텍처에의 적용**: QLoRA를 다양한 모델 아키텍처에 적용하여 일반화 가능성을 검증할 필요가 있습니다. 예를 들어, Transformer 이외의 모델에도 QLoRA를 적용해 볼 수 있습니다.
- **실시간 응용**: 실시간 응용 분야에서의 활용 가능성을 탐색할 필요가 있습니다. 예를 들어, QLoRA를 사용하여 모바일 기기에서 실시간 번역을 수행할 수 있습니다.
- **LoRA rank 최적화**: 모델 및 데이터셋에 따른 최적의 LoRA rank를 자동으로 결정하는 연구가 필요합니다.

## 실무 적용 가이드

- **하드웨어 고려사항**: 단일 48GB GPU에서도 효율적으로 작동하므로, 대규모 클러스터 없이도 활용이 가능합니다. 하지만, 더 큰 모델이나 데이터셋을 사용하는 경우 더 많은 GPU 메모리가 필요할 수 있습니다.
- **데이터셋 선택**: 데이터셋의 품질이 성능에 큰 영향을 미치므로, 고품질 데이터셋을 선택하는 것이 중요합니다. 데이터셋의 편향을 줄이기 위한 노력도 필요합니다.
- **하이퍼파라미터 튜닝**: 모델과 데이터셋에 맞는 하이퍼파라미터를 조정하여 최적의 성능을 얻을 수 있습니다. Learning rate, weight decay, rank 등의 하이퍼파라미터를 신중하게 튜닝해야 합니다.
- **사전 학습 모델 선택**: QLoRA를 적용할 사전 학습 모델을 신중하게 선택해야 합니다. 모델의 크기, 구조, 학습 데이터 등을 고려해야 합니다.

## 결론

QLoRA는 대규모 언어 모델의 미세 조정을 위한 효율적인 방법론을 제안합니다. 4-bit 양자화와 저랭크 어댑터를 결합하여 메모리 사용량을 크게 줄이면서도 성능을 유지할 수 있습니다. 이는 자원 제약적인 환경에서도 대규모 모델을 효과적으로 활용할 수 있는 가능성을 제시합니다. QLoRA는 대규모 언어 모델 연구 및 개발에 새로운 가능성을 열어줄 것으로 기대됩니다.

## 참고 자료

- [논문 링크](https://arxiv.org/abs/2305.14314)
- [코드 저장소](https://github.com/TimDettmers/qlora)
- [관련 자료](https://arxiv.org/list/cs.LG/recent)